[TOC]
# 面试大汇总
## 需要好好斟酌准备的
### 1. 自我介绍
### 2. 项目的内容，项目的人员分配，项目的代码量
### 3. 项目拓展内容，一定要好好总结，挖掘知识点
- 腾讯面试官说的没错，做一个项目不是说你做完就完事儿了，一定要搞清楚你学了什么东西，以后工作的时候不是让你重新做一遍曾经做过的项目，而是有这个经验之后再有类似的工作就会得心应手很多。
### 4. 服务器项目
#### 1). 整体设计
#### 2). 并发量
- QPS(TPS)：
#### 3). 负载均衡
- HTTP重定向负载均衡
  优点：简单
  缺点：浏览器需要两次请求服务器才能完成一次访问，性能较差
- DNS域名解析负载均衡
  优点：将负载均衡的工作交给DNS，省掉了网站管理的维护服务器的麻烦，加快用户访问速度，改善性能。
  缺点：解析的地址可能是已经下线的服务器，导致用户访问失败；
- 反向代理负载均衡(应用层负载均衡)
  优点：和反向代理服务器功能集成在一起，部署简单。
  缺点：反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。
- IP负载均衡
- 数据链路层负载均衡(三角传输模式)
- 负载均衡算法
  **轮询**
  **加权轮询**
  **随机**
  **最少链接**
  **源地址散列**
#### 4). 项目开发过程中遇到的难点
- 最初的架构设计
- 数据安全
- 稳定性
- 扩展性
#### 5). 编写服务器程序需要考虑的因素

- 系统的硬件资源，比如说CPU个数，速度，内存大小等。不过由于硬件技术的飞速发展，现代服务器都不缺乏硬件资源。因此，需要考虑的主要问题是如何从“软环境”来提升服务器的性能。服务器的”软环境“
- 一方面是指系统的软件资源，比如操作系统允许用户打开的最大文件描述符数量
- 另一方面指的就是服务器程序本身，即如何从编程的角度来确保服务器的性能。主要就要考虑大量并发的处理这涉及到使用进程池或线程池实现高效的并发模式（半同步/半异步和领导者/追随者模式），以及高效的逻辑处理方式--有限状态机内存的规划使用比如使用内存池，以空间换时间，被事先创建好，避免动态分配，减少了服务器对内核的访问频率，数据的复制，服务器程序还应该避免不必要的数据复制，尤其是当数据复制发生在用户空间和内核空间之间时。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区拷贝到应用程序缓冲区中。这里所谓的“直接处理”，是指应用程序不关心这些数据的具体内容是什么，不需要对它们作任何分析。比如说ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及是否有权限读取就可以了，不需要知道这个文件的具体内容，这样的话ftp服务器就不需要把目标文件读入应用程序缓冲区然后调用send函数来发送，而是直接使用“零拷贝”函数sendfile直接将其发送给客户端。另外，用户代码空间的数据赋值也应该尽可能的避免复制。当两个工作进程之间需要传递大量的数据时，我们就应该考虑使用共享内存来在他们直接直接共享这些数据，而不是使用管道或者消息队列来传递。上下文切换和锁：并发程序必须考虑上下文的切换问题，即进程切换或线程切换所导致的系统开销。即时I/O密集型服务器也不应该使用过多的工作线程（或工作进程），否则进程间切换将占用大量的CPU时间，服务器真正处理业务逻辑的CPU时间比重就下降了。因此为每个客户连接都创建一个工作线程是不可取的。应该使用某种高效的并发模式。（半同步半异步或者说领导者追随者模式）另一个问题就是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为由他引入的代码不仅不处理业务逻辑，而且需要访问内核资源，因此如果服务器有更好的解决方案，应该尽量避免使用锁。或者说服务器一定非要使用锁的话，尽量使用细粒度的锁，比如读写锁，当工作线程都只读一块内存区域时，读写锁不会增加系统开销，而只有当需要写时才真正需要锁住这块内存区域。对于高峰和低峰的伸缩处理，适度的缓存


#### 6). 无锁编程
- CAS(Compare and Swap),无锁编程算法。无锁编程是指在线程没有被阻塞的情况下实现多线程之间的变量同步。CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 **乐观锁** 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
```cpp
int compare_and_swap (int* reg, intoldval, intnewval)
{
  intold_reg_val = *reg;
  if(old_reg_val == oldval)
     *reg = newval;
  returnold_reg_val;
}
```
- CAS缺点：
1. CPU开销大，在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直不成功，循环往复，会给CPU带来很大的压力。
2. 不能保证代码块的原子性。CAS机制所保证的只是一个变量的原子性。
3. ABA问题：考虑有两个线程按照如下顺序执行：
1). 线程1读取内存中数据为A
2). 线程2将该数据修改为B
3). 线程2将该数据修改为A
4). 线程1对数据进行CAS操作
有效解决方法是，引入版本号。内存中的值每次发生变化，版本号都加1，进行CAS操作时，不仅比较内存中的值，还比较版本号。

#### 7). one-thread-one-loop
- 优点：
- 线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁
- 可以很方便地在线程间调配负载
- IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发
- EventLoop代表了线程的主循环，需要让哪个线程干活，就把timer或IO channel注册到哪个线程的loop里即可。对实时性要求高的connection可以单独用一个线程；数据量大的connnection可以独占一个线程，并把数据处理任务分摊到几个计算线程中；其他次要辅助的connections可以共享一个线程。

#### 8). 协议的选择
- 选择二进制协议，是因为用的TCP直连，消息的定义统一采用消息头(消息ID+消息长度)+消息内容的方式。优点：
1. 节约内存，带宽
2. 方便加密
缺点：
1. 难以解析
2. 不方便消息的修改

#### 9). 定时器的设计
- 常见定时器的实现有：排序链表，最小堆，时间轮。
![6df97bb2d6137ba83ea79d93c7399890.png](en-resource://database/1439:1)



## 分布式
### 1. Raft协议
- 分布式系统除了提升整个系统的性能外，还有一个重要的特征就是提高系统的可靠性。提高可靠性可以理解为系统中一台或多台的机器故障不会使系统不可用。保证系统可靠性的关键就是多副本，一旦有副本就牵扯到一致性问题。一致性算法正是用于解决分布式环境下多副本之间数据一致性的问题。
- Raft是一种管理复制日志的一致性算法，它将一致性拆分成几个关键元素：
1. Leader选举
2. 日志复制
3. 安全性

### 2. 分布式事务
- 分布式事务是指事务的参与者，支持服务的服务器，资源服务器以及事务服务器分别位于不同的分布式系统的不同节点之上，就是一个大的操作由不同的小操作组成，这些小操作分布在不同的服务器上。


## 常会考的数据库

### 1. 数据库一致性问题

### 2. 如何保证缓存与数据库的双写一致性？(如何设计缓存，保证数据写入和读取的数据一致性?)
  - 最经典的缓存+数据库读写的模式是：Cache Aside Pattern，读的时候，先读缓存，如果没有在读DB，然后取出数据后放入缓存，同时
  返回响应。更新的时候，先删除缓存，然后更新数据库。
  
### 3. mysql, mongodb, redis之间的区别？
- MongoDB和Redis是Nosql数据库，Mysql是sql数据库。
- 非关系型数据库的优势：
  1). 性能
  2). 可扩展性
  关系型数据库的优势：
  1). 复杂查询
  2). 事务支持
  
### 4. 数据库事务的四大特征？
- 数据库事务指的是作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全失败
- ACID：
- **原子性**
- **一致性**：指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态
- **隔离性**：同一时间，只允许一个事务请求同一个数据，不同的事务之间彼此没有任何干扰。
4种隔离级别：
1. 读未提交：最低的隔离级别。什么都不需要做，一个事务可以读到另一个事务未提交的结果。
2. 读取提交内容：只有在事务提交之后才可以被其他事务看到。可以解决**脏读**的问题。
3. 可重复读：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作。可以解决**脏读，不可重复读**
4. 串行化：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决**并发事务的所有问题**。
- 若是不考虑事务的隔离性，会发生：
1. 脏读：指一个事务处理过程读取了另一个未提交的事务的数据。
2. 不可重复度
3. 幻读：幻读和不可重复读都是读取了另一个以经提交的事务，不可重复读的重点在于update和delete，而幻读的重点在于insert。
- **持久性**：事务完成后，它对数据库的改变是永久性的。




### 5. 数据库范式
- 第一范式1NF：强调列的原子性，即列不能够再分成其他几列
- 第二范式2NF：首先是1NF，另外包含，表必须有主键；没有包含主键的列必须完全依赖于主键，而不能依赖于主键的一部分
- 第三范式3NF：首先是2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖

### 6. 数据库锁
- 共享锁：(读取)操作创建的锁，其他客户可以并发访问读取数据，但任何事务都不能获取数据上的排它锁，直到释放所有共享锁。
- 排它锁：对数据A加上排它锁后，其他事务不能在对数据A加任何类型的锁。
- 更新锁：更新锁可以防止通常形式的死锁。如果两个数据获得了资源上的共享锁，然后试图同时更新数据，则两个事务都需要转换共享锁为排它锁，并且每个事务都等待另一个事务释放共享锁，因此会发生死锁。
因此，使用更新锁，一次只有一个事务可以获得资源的更新锁。如果事务修改资源，则更新锁转为排它锁。否则为共享锁。
- 锁的粒度：
1. **行锁**： 粒度最小，并发性最高
2. **页锁**： 一次锁定一个页
3. **表锁**： 粒度大，并发度低
4. **数据库锁**： 控制整个数据库操作

### 7. Redis有哪些数据结构？
- 字符串String ： value不仅可以是string，也可以是数字
- Hash
- 列表List，实现用的是双向链表，用途是消息队列(push/pop操作), 最新消息排列
- 集合Set：不重复值的组合，应用：可以统计共同好友，好友推荐（根据tag求交集，大于某个threashold就可以推荐)
- 有序结合Zset：将set中的元素增加了一个权重参数score，使得集合中的元素能够按照score进行有序排列
- 订阅发布系统Pub/Sub：可以设定某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。用途：实时消息系统。
- 事务Transactions：并不是严格的ACID的事务，提供了基本的命令打包功能(在服务器不出问题的情况下，可以保证一连串的命令是顺序一起执行的，中间会有其他客户端命令穿插进来)

### 8. Redis为什么是单线程的？
- 多线程会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。CPU不是Redis的瓶颈，瓶颈可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过单机开多个实例来解决。

### 9. Redis单点吞吐量？
- 单点TPS到达8w/s，QPS：10w/s

### 10. Redis数据淘汰策略？
- volatile-lru：从已设置过期的数据集中挑选**最近最少使用**的策略
- volatile-ttr：从已设置过期的数据集中挑选**要过期**的数据淘汰
- volati-random：从已设置过期的数据集中**任意挑选**数据淘汰
- allkeys-lru：从数据集中挑选**最近最少使用**的数据淘汰
- allkeys-random：从数据集中挑选**要过期**的数据淘汰
- noenviction：禁止淘汰数据

### 11. Redis集群方案？
- Redis集群是一个可以在多个Redis节点之间共享数据的设施，redis集群不支持那些需要同时处理多个键的redis命令，因为执行这些命令需要在多个redis节点之间移动数据，并且在高负载的情况下，这些命令将降低Redis集群的性能，并导致不可预测的错误。
- Redis集群的好处：
1. 将数据自动切分到多个节点的能力
2. 当集群中的一部分节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。
- Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务
- Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储

### 12. Redis持久化方式？
- **RDB**做全局持久化，**AOF**做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要配合AOF来使用。在Redis实例重启时，会使用rdb持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
- **RDB**, 能够在指定时间间隔能对数据进行快照存储，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。RDB的原理是，通过创建子进程，父子进程共享数据段，父进程提供读写服务
- **AOF**， 以日志的形式记录每个写操作，只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍已完成数据的恢复工作。

### 13. Redis分布式锁？
- 先拿setnx来争抢锁，抢到之后，再用expire给锁一个过期时间防止锁忘记释放。
- 若是再setnx之后执行expire之前进程意外crash或者重启维护了，应该用set的一些参数将setnx和expire合成一条指令来用
- 如何生产一次消费多次？使用pub/sub订阅者模式。pub/sub模式的缺点：在消费者下线的情况下，生产的消息会丢失，使得用专业的消息队列rabbitmq



### 14. 假如Redis里面有一亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将他们全部找出来？
- 使用**key**指令可以找出指定模式的kye列表
- 若是这个redis正在线上的业务提供服务，那么由于redis是单线程的，执行key指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才会恢复。这时可以使用**scan**指令，scan可以无阻塞的提取出指定模式的key列表，但是会存在一定的重复概率。

### 15. Redis异步队列？
- 一般使用**list**作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息时，要适当sleep一会
- 若是不使用sleep，可以使用list的bpop，在没有消息的时候，它会阻塞直到消息到来。


### 14. Redis如何实现延时队列？
- 使用sortedset，用时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之后的数据轮询进行处理。


### 14. Redis同步机制？
- Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 15. MongoDB副本集实现高可用的原理
- https://blog.51cto.com/arthur376/2165039

## C++语言方面
### 1. C++内存泄漏怎么办?如何判断是否有内存泄漏，怎样去定位？
   - 使用一些如BoundsChecker， valgrind等工具检测，这个工具可以定位程序运行时的内存泄露
   - 调试运行DEBUG程序，运用CRT(C run-time libraries),运行时调用堆栈，内存泄露时提示的内存分配序号，综合分析内存泄漏的原因。
   - 编写代码的时候用智能指针。
   - windows平台用vs和CRT库检测和识别。原理：内存分配通过CRT再运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时，对比分配内存和释放内存的记录就可以确定是否有内存泄漏。
### 2. C++编译时如何排查错误？
### 3. C++中几种智能指针的区别？
### 4. Vector和List的区别，底层实现？
### 5. 链表有单向链表和双向链表，区别以及使用场景？
### 6. hash表，实现和应用？
- hash表是通过哈希函数实现的，每个元素存储是通过哈希函数计算存储地址。哈希表的平均查找长度取决于哈希函数的装填因子$\alpha$。
- 解决冲突的方法有：
 1). 链地址法
 2). 开放地址法
 3). 再散列
 4). 建立公共溢出区
### 7. C++编译的过程？
### 8. 内存池？
   1). 先申请一个大的内存空间
   2). 每个对象连同指向下一个对象的指针一起构成一个内存结点。各个空闲的内存结点通过指针形成一个链表，链表的每一个内存结点都是可供分配的内存空间。
   3). 某个内存结点被分配，从空闲链表中删除
   4). 释放某个内存结点的空间后，插入到空闲链表中
   5). 若一个内存块的所有内存都已经分配完毕，若程序继续申请新的对象空间，则会再此申请一个内存块来容纳新的对象。
   ![2b0e9c8551de51fafd772397d2ca3944.png](en-resource://database/1181:1)
   详解请看：[内存池](https://blog.csdn.net/K346K346/article/details/49538975)
### 9.动态链接与静态链接
![b20c8e0f6cd9093507e79a3401405726.png](en-resource://database/1183:1)
两种不同的ELF格式映像：
- 静态链接：把需要用到的库函数的代码(二进制)从程序库中抽取出来，链接进应用程序的目标镜像中
- 动态链接：库函数的代码并不进入应用软件的目标镜像，只是把函数的镜像交给用户，到启动时才装载到用户控件。
### 10. 指针和引用的区别？
### 11. 如何实现多态？为什么只能用指针，引用来实现多态？
### 12. 如何只在栈上或者堆上实例化对象？
- 只在栈上实例化，故需阻止对象调用new的方法创建对象，而**new operator总是先调用operator new**，故只需重载operator new，并将其设为私有的就可以。
- 只在堆上实例化，即阻止对象不得使用new之外的方法创建对象，所以只要让那些被隐士调用的构造函数和析构函数动作不合法就可以了。常用的做法是将析构函数设为私有的。
### 13. 内存分配？
- C++程序的内存分配为：全局数据区，代码区，栈区，堆区。
- 代码区用来存放存放程序执行的机器指令，**类成员函数和非成员函数代码**。
- 数据区(已初始化数据段和未初始化数据段)用来存放**全局变量，静态变量，和常量**， 特别的**类的静态成员变量，虚函数表**存放在此区域。
- 栈区存放为运行函数分配的局部变量。函数参数，返回数据，返回地址等。
- 堆区则存放用户自己分配的内存空间。
 ![d3d323b6d78c2f3bc11b78dfa8854453.png](en-resource://database/1570:1)
 


### 14. 虚函数可以是内联函数吗？多重继承下的虚函数表？
- 多态的时候不可以，其他时候可以
- 类的虚函数表在编译的时候就确定了，存放在只读数据段中。
- 多重继承下，有多少基类就有多少个虚函数表。


### 15. strcpy的安全性？
   - strcpy原型：`char *strcpy(char *strDest, char *strSrc)`,若strDest的内存空间不够大，可能会出现缓冲区溢出的错误，可以用strncpy来完成同样的任务
### 16. malloc最大申请多大内存？
进程分配内存有两种方式：brk和mmap
- brk是将数据段的最高地址指针往高地址推。
当内存小于128K时，使用brk分配内存
- mmap是在进程的虚拟空间中(堆和栈中间，文件映射区域),找一块空闲的虚拟内存。
当内存大于128K时，使用mmap分配内存，在堆和栈之间找一块空闲内存分配。
### 17. gdb

### 18. 哈夫曼树，哈夫曼编码

### 19. 常量指针和指针常量
- 常量指针是指针指向的内容不可变，const *p, 底层const
- 指针常量是指针的指向不可变，*const p, 顶层const

### 20. map与unorder_map的区别以及适用处？
- map底层采用的是红黑树，因此可以保证有序性，但空间占用率高，适用于有顺序要求的问题。
- unordered_map底层采用了哈希表，查找速度很快，但建立哈希表耗费时间，适用于查找问题。

### 21. 四种强制类型转换？
- const_cast: 常量指针(引用)转换为非常量指针(引用)
- static_cast: 用于基本数据类型之间的转换，用于类层次机构中基类和派生类之间指针和引用的转换，进行上行转换(派生类转基类)是安全的，下行转换是不安全的。
- dynami_cast: 将一个基类指针(或引用)转换到继承类指针(或引用)，具有多态性
- reinterpret_cast: 强制类型转换符用来处理无关类型的。

### 22. hashmap如何实现存储的？

### 23. 迭代器失效问题？
- vector和dequeue采用的是连续内存分配，insert和erase操作会使插入点删除点之后的位置失效，但erase会返回下一个有效的迭代器。
- 链表和树形数据结构，插入不会使迭代器失效，erase会使删除位置的迭代器失效。

### 24. 什么情况下必须要拷贝构造函数？
- **三/五法则**：如果这类需要一个析构函数，那么它也需要一个拷贝构造函数和拷贝赋值函数。
                      如果一个类需要一个拷贝构造函数，那么也需要一个拷贝赋值运算符。
                      如果一个类需要一个拷贝赋值运算符，那么也需要一个拷贝构造函数。
- 调用拷贝构造函数还是赋值函数，主要看是否有新的对象产生，如果有新的对象产生则调用的时拷贝构造函数。
### 25. 类拷贝，赋值与销毁
- 析构函数是不能被删除的成员。
- 合成的拷贝控制成员可能是删除的：如果一个类由数据成员不能默认构造，拷贝，赋值或销毁，则对应的成员函数将被定义为删除的。

### 26. 移动构造函数和右值引用？
- 新标准的**移动构造函数**可以将资源从给定对象“移动”而不是拷贝到正在创建的对象。也可通过utility头文件下的std::move()来实现。移动构造函数不分配新内存。
- 右值引用就是必须绑定到右值的引用。只能绑定到将要被销毁的对象。
- 左值右值：
  左值是一个对象的身份(在内存的位置),右值是对象的值。
  
### 27. new出来的对象调用free会发生什么？
- new的操作是分两步：调用operator new,再运行相应的构造函数。若是new出来的对象调用free将不会执行析构函数，这就有可能造成内存泄漏。

### 28. 怎么判断栈的生长方向？
- 设计两个函数funcA, funcB，funcA作为调用方,funcB作为被调用方，被调用方funcB(int *a)以一个地址作为入口参数，调用方funcA传入的参数是自己的一个局部变量的地址，然后被调用方funcB比较这个地址和自己的一个局部变量地址，即可确认栈增长方向。原理是：先调用的函数先入栈。
```cpp

void funcA();
void funcB(int *a);

void funcA()
{
    int a=0;
    funcB(&a);
}
void funcB(int *a)
{
    int b=0;
    printf("%x\n%x\n",a,&b);
}


int main()
{
    funcA();
}
```

### 29. 内存管理的方式有哪些？
- 智能指针
- RAII(Resource Acquisition Is Initialization)，资源获取即初始化.即在类的构造函数中分配资源，在析构函数中释放资源。

### 30. 子类构造函数和析构函数调用虚函数？
- 绝不在构造函数和析构函数调用虚函数，这是因为，执行子类的构造函数时总是先执行基类的构造函数，故在构造函数中调用虚函数，不会向下调用。假如，构造函数中的虚函数可以向下调用，而在子类执行的时候必然会用到子类的一些变量，但此时子类并未初始化，故会造成错误。析构函数同理。

### 31. C++中静态局部变量初始化是不是线程安全的？
- 网上有两种解释：在C++11之前，是不安全的，但在C++11保证静态局部变量的初始化过程是线程安全的。。
- 是否安全的验证方法：输出现在的时间，启动两个线程调用所需的变量函数，结尾再输出结果，若三个时间都是x，x+5，x+5,那么他就是线程安全的。
- 非局部静态变量是线程安全的。

### 32. shared_ptr的线程安全？
- shared_ptr不是100%线程安全的，它的引用计数时安全且无锁的，但对象的读写不是，因为，shared_ptr有两个数据成员，读写操作不能原子化。
- 如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。

### 34. 空类默认有哪些函数？
- 对于一个没有实例化的空类，编译器不会给它产生任何函数，当实例化一个空类后，编译器会根据需要生成对应的函数(默认构造函数，默认析构函数，默认拷贝构造函数，默认赋值函数，默认取地址符函数)。

### 35. lambda与闭包，匿名函数的区别？
- 从功能上来说，lambda和闭包时一个东西，知识不同语言的不同称呼，都是匿名函数。当匿名函数捕获了一个外部变量，那么它就是一个闭包。

### 36. lambda的底层实现？
- 原理：编译器会把lambad表达式生成一个匿名类的匿名对象，并在类中重载调用运算符。


### 37. int, long, long long的范围大小


| 类型 |位  |范围  |
| --- | --- | --- |
|char |1个字节 |[-128, 127 ] 或 [0, 255]  |
|int  |4个字节  |[-214783648, 214783647]  |
|float  |4个字节  |+/-3.4e+/-38  |
|double  |8个字节  |+/-1.7e+/-308  |
|long  |在32位占4个字节，64位占8个字节  |[-214783648, 214783647]   |
|long long |8个字节 |[-9223372036854775807, 9223372036854775808] |

### 38. volatile关键字
- volatile关键字是一种类型修饰符，用它声明的变量表示可以被有些编译器未知的因素更改。volatile修饰的关键字每次用到的时候必须从它的地址中读取，这样可以防止某些编译器优化的时候把变量从内存装入CPU寄存器中。另外更多的可能是多线程并发访问变量时，用volatile修饰。
通常用在：
1). 中断服务程序中修改的供其他程序检测的变量需要加volatile 
2). 多任务环境下个任务间共享的标志应该加volatile
3). 存储器一个色的硬件寄存器通常也要加volatile
- 一个参数被const修饰后也可以被volatile修饰，这是因为被const修饰是告诉程序不应该去修改，而volatile则是说明，它可能被一些意外情况修改。
- 一个指针也可以被volatile修饰。

### 39. 指针数组和数组指针
- 指针数组， int *a[10],  a是一个数组，该数组的元素是指针，每个指针指向int型
- 数组指针， int (*a)[10], a是一个指针，指向一个10个元素的int类型的数组


### 40. #define是怎么展开的？
- #define是在编译时展开，展开有两种语法，一种是带参数，一种不带参数

### 41. #ifdef #if(条件编译)
- 条件编译是指满足某一条件时才进行编译，不满足时编译另一些语句。
- 用法：
```cpp 
  #ifdef micro_name
      程序段1
  #else
      程序段2
  #endif
  
  #if 表达式
      程序段1
  #else
      程序段2
  #endif
```

### 42. free()函数入参是一个void*指针，它是如何知道被指向的大小的？
- 空间的大小记录在参数指针指向地址的前面，free的时候通过这个记录即可知道要释放的内存有多大。具体的需了解虚拟内存的分配方式，见CSAPP Ch9

### 43. c/c++程序如何控制执行到某个特定内存地址？
- 可以通过将地址包装成函数指针的方式，来执行到某个特定内存地址，[例子](https://blog.csdn.net/electrocrazy/article/details/79709947)

### 44. 构造函数和析构函数可以是虚函数吗？
- 构造函数不能是虚函数：
1. 虚函数调用需要vptr指针，而该指针存放在对象的内存空间中，需要调用构造函数才可以创建它的值，否则即使开辟了内存空间，该vptr的值也为随机值；若构造函数是虚函数，那么由于对象还没创建，还没有内存空间，更没有vptr地址用来调用虚函数构造函数。
2. 虚函数主要用于实现多态，在运行时才可以确定调用对象，根据传入的对象类型来调用函数。构造函数是对象主动调用的，不可能通过父类的指针或引用去调用。
- 析构函数通常是虚函数。


### 45. map中key如果是结构体，需要注意什么？
- 因为stl中map的底层实现是以**红黑树**为基础机构的，map中的元素是有序的，而结构体作为key，无法排序。故需要在结构体中重载比较操作。

### 46. 如何比较两float是否相等
- 相减：abs(a - b) <= 1e-6
- 扩大再取整：扩大几百倍转换成int类型


## 变化多端的数据结构
### 1. 排序的种种
- 复杂度与状态无关的：**选择排序**，**归并排序**，**堆排序**，**计数排序**
- 总排序趟数与初始状态无关：除了**快速排序**和优化后的冒泡，其他都相关
- 元素总比较次数与初始状态无关：**计数排序**，**选择排序**
  在长度为n的顺序表，**快速排序**的最坏比较次数为$\frac{n(n-1)}{2}$, 堆排序的最坏比较次数为$nlog_2n$
- 元素总移动次数与初始状态无关：**计数排序**，**归并排序**

### 2. 红黑树和B+数的区别以及各自复杂度？都应用于哪些场景？
- [详情请看](https://blog.csdn.net/whoamiyang/article/details/51926985)
- B树：平衡多路查找树
1. 排序方式：所有节点关键字按照递增次序排列，并遵循左小右大原则。
2. 子节点数：非叶节点的 $1 < 子节点数 <=M,且M>=2$, 空树除外
3. 关键字数：枝节点的关键字数量大于 $\frac{m}{2}-1$,且小于$M-1$个
4. 所有叶子节点均处于同一层
**特点**：B树与二叉搜索树不同的是每个节点包含的关键字增多了，特别是B树应用到数据库的时候，数据库充分利用了磁盘块的原理，把节点大小限制和充分使用在磁盘块大小范围。
- B+树:
**特点：**
1. B+树**层级更少**：相较于B树，B+树每个非叶节点存储的关键字数更多，树的层级更少，所以查询数据更快
2. B+树**查询速度更稳定**
3. B+树**具备排序功能**：所有关键字都存储到叶子节点，其可以构成一个有序链表
4. B+树**全局遍历更快**：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样对每一层进行遍历


### 3. 有百万个QQ号，我现在要放一个QQ号进来，如果在就返回，不在就插入。设计一个存储结构要满足快速查询，其次要存储空间小。
- 利用字典树，构建需要O(n),查询需要O(logn)。

### 4. LSM树
- 




## 都会被问的操作系统
### 1. 锁都有哪些？
- **互斥锁mutex**，**自旋锁spin lock**， **读写锁**
- **自旋锁**：自旋锁不会引起调用者睡眠，它是一种busy-waiting类型的锁，如果线程使用的是pthread_spin_lock操作去请求锁，那么线程就会一直在忙等待并不停的j进行锁请求，直到得到这个锁为止。它的原理是，线程一直进行（加锁-解锁）操作，死循环监测锁的标志位。
- **互斥锁**：互斥锁是sleeping-wating类型的锁。原理是线程会从sleep(加锁)-running(解锁),过程中会有上下文切换，cpu的抢占，信号的发送等开销。
- **互斥锁应用范围**： 互斥锁常用于临界区持锁时间比较长的操作，如临界区有IO操作，单核处理器等。
- **自旋锁应用范围**： 自旋锁常用于临界区持锁时间非常短且CPU资源不紧张的情况下，一般用于多核处理器。
    
### 2. 线程通信都有哪些？互斥量与信号量的区别？
- 线程通信方式：
  1). 临界区
  2). 互斥量
  3). 信号量
  4). 事件(信号)
- 互斥量和信号量的区别：
  1). 互斥量用于线程的互斥，信号量用于线程的同步。 
  2). 互斥量只能为0/1，信号量可以为非负整数。
  3). 互斥量加锁解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。
[详细](https://www.cnblogs.com/LUO77/p/5816326.html)
  

### 3. 进程线程的区别？
- 线程私有的：**线程id，寄存器的值，栈，线程的优先级和调度策略，线程的私有数据，信号屏蔽字，errno变量**

（1）进程与进程之间的数据空间是分开的，如果要在进程之间进行通信，需要使用特殊的IPC机制，比如管道、信号量、共享内存、消息队列。线程是存在于进程内的，线程之间共享进程的堆区间、全局静态存储区，而各自享有自己独立的栈空间。线程之间共享数据比较简单，但是线程之间的同步比较复杂，线程同步方法比如说使用互斥量mutex、信号量semaphore。

（2）进程的创建、销毁、切换复杂，速度比较慢。线程的创建、销毁、切换简单，速度快。

（3）进程占用内存多，CPU利用率较低。线程占用内存少，CPU利用率高。

（4）进程之间不会相互影响。进程的一个线程挂掉则会导致整个进程挂掉。

（5）进程适应于多核多机分布，线程适应于多核。
### 4. 内核的中断？
- CPU中断：
1. 硬件中断：可屏蔽中断，非屏蔽中断
2. 软件中断：内部中断
- 中断的过程：
1. 中断请求
2. 中断相应，请求和返回
3. 中断返回和中断判优
- 多核CPU对中断的处理：主要使用APIC，即高级编程中断控制器
### 5. 分段分页？
 - **分页**
   逻辑地址 = 页号 + 页内地址
   物理地址= 块号 + 页内地址
   逻辑地址到物理地址的映射关系：
   ![992707c99d41282a77424246fff31ec7.png](en-resource://database/1175:1)
   若给出逻辑地址，求页号是用逻辑地址除以页的大小，得出的商即为页号，而取模即为页内的偏移量即页内   地址，如：
   ![2973218f6be9e27ea8a17315b4a3ae18.png](en-resource://database/1177:1)
   首先求页号：因为页的大小为8K，故$9612 \div (8 \times 1024)=1$
   再求偏移量：$9612 \%(8 \times 1024)=1420$
   故物理地址为：块号+页内地址= 3 * 8 * 1024 + 1420 = 25996
 - **分段**
   ![d1fff93070be64bdbf694ef6d7608180.png](en-resource://database/1179:1)
   两者的详细区别看：[分页分段](https://blog.csdn.net/zephyr_be_brave/article/details/8944967)
- 在段页式存储管理方式中，CPU每次读取一条指令需要访问内存**3**次：首先是从内存中查找段表，然后再查找页表，最后根据页表凭借成物理地址访问内存获得指令或数据。
 ### 6. LRU底层实现？
 - 利用哈希表和双链表

### 7. 多线程同步和安全问题？
- 线程安全：一个函数被称为线程安全意味着当且仅当多个并发线程反复调用的时候，会一直产生正确的结果。
- 线程安全的条件：保证线程的安全主要是线程之间的共享变量。同一进程的不同线程会共享进程内存空间的全局区和堆，私有的线程空间则包括了栈和寄存器。因此，同一个进程的不同线程来说，每个线程的**局部变量都是私有的**，**全局变量，局部静态变量，分配于堆的变量**都是共享的。要保证线程的安全，必须通过**加锁**的方式。

### 8. 多线程多进程的选择？
- 需要频繁创建销毁的优先使用线程：如web服务器，用线程创建连接。
- 需要大量计算的优先使用线程：图像处理，算法处理。
- 可能扩展到多机分布的使用线程，多核分布使用线程。

### 9. 线程池实现原理？
- 线程池使用的场景：
  1). 单位时间内处理任务频繁而且任务处理时间短
  2). 对实时性要求较高。
  
### 10. 乐观锁和悲观锁
- 悲观锁总是假设最坏的情况，每次去拿数据都会上锁，传统的关系型数据库就用到了很多这种锁机制，如行锁，表锁，读锁，写锁等。
- 乐观锁总是假设最好的情况，每次拿数据不会上锁，但是更新的时候会判断此期间是否有人更新数据。
- 乐观锁适合多读少写的情况，悲观锁适用于多写的情况。

### 11. 100个线程，每个线程功能为对一个数加100次，最后得到结果为10000，要如何实现，不能用锁。
- 现在能想到的是将这个数搞成原子性。

### 12. 多线程锁的种类
- **互斥锁，读写锁，自旋锁，递归锁* *

### 13. linux系统的各类同步机制，什么是死锁，如何避免死锁？
- 同步机制有：**原子操作**，**信号量**， **读写信号量**， **自旋锁**， **内核锁**，**顺序锁**。
- 死锁的必要条件： **资源是互斥的**，**不可抢占**， **请求和保持**， **循环等待**。

### 14. 如何实现守护进程？
- 创建子进程，父进程退出
- 在子进程中新建会话
- 改变当前路径为根目录
- 重设文件权限掩码
- 关闭文件描述符
- 守护进程退出处理

### 15. 如何向进程发送信号？
- 用kill向进程发送信号
- 一个进程向另一个发送
- 从键盘给进程发送信号

### 16. 文件读写的基本流程？
- 读文件：
1、进程调用库函数向内核发起读文件请求；
2、内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项；
3、调用该文件可用的系统调用函数read()3、read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode；
4、在inode中，通过文件内容偏移量计算出要读取的页；
5、通过inode找到文件对应的address_space；
6、在address_space中访问该文件的页缓存树，查找对应的页缓存结点：（1）如果页缓存命中，那么直接返回文件内容；（2）如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存；
7、文件内容读取成功。
- 写文件：
前5步和读文件一致，在address_space中查询对应页的页缓存是否存在：
6、如果页缓存命中，直接把文件内容修改更新在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。
7、如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。
8、一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：（1）手动调用sync()或者fsync()系统调用把脏页写回（2）pdflush进程会定时把脏页写回到磁盘同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。
[详细](https://www.cnblogs.com/huxiao-tee/p/4657851.html)

### 17. Zero Copy的实现原理？
- [详细](https://juejin.im/post/5d84bd1f6fb9a06b2d780df7)

### 18. 如何解决栈溢出？
- 用栈把递归转换成非递归
- 用static对象替换non-static对象
- 增大堆栈大小值


### 19. 外部碎片，内部碎片？
- 外部碎片是指在一段连续的页框中，因为申请释放等原因造成的不满足新内存申请要求但却有空闲的情况，如下图：
![7719363aadf005f54ca123b9f081e780.png](en-resource://database/1433:1)
- 内部碎片是指：当我们申请一个较小内存时，内核分配了一个页，这样在每个页中就形成了很大的浪费。
- 用slab机制解决内部碎片： slab分配器是基于对象进行管理的，所谓的对象是内核中的数据结构。相同类型的对象归为一类，每当申请这样一个对象时，slab分配器就从slab列表分配一个这样大小的单元出去，而当要释放的时候，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片
![4a27da021704ec49aaa5b74698fab127.png](en-resource://database/1434:1)


### 20. 进程切换和线程切换？
- 进程切换分为两步：
1. 切换页目录以及使用新的地址空间
2. 切换内核栈和硬件上下文
- 切换的开销：
1. 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间是相同的，而进程切换是不同的。
2. 上下文切换时会扰乱处理器的缓存机制。


### 21. Linux任务调度
- linux系统支持实时和非实时两种进程。实时进程相对于普通进程拥有绝对的优先级。
- 实时进程采用**SCHED_FIFO**或**SCHED_RR**调度策略；普通进程则采用SCHED_OTHER调度策略。
- **SCHED_FIFO：** 不同的进程根据静态优先级进行排队，然后在同一优先级的队列中，谁先准备好运行就先调度谁，并且正在运行的进程不会被终止直到以下情况发生：（1）.被有更高优先级的进程所强占CPU；（2）.自己因为资源请求而阻塞；（3）.自己主动放弃CPU（调用sched_yield）。
- **SCHED_RR：** 这种调度策略跟上面的SCHED_FIFO一模一样，除了它给每个进程分配一个时间片，时间片到了正在执行的进程就放弃执行；时间片的长度可以通过sched_rr_get_interval调用得到。


### 22. 内存对齐
- 为什么要进行内存对齐：1. 平台(移植)原因 2. 性能原因, 处理器是通过粒度进行读取
- 内存对齐的优点是空间换时间


### 23. 共享内存的实现原理
- 文件映射：通过mmap函数要求内核创建一个虚拟存储器区域，并将文件描述符fd指定对象的一个连续片映射到这个新的区域

## 懵懂的网络
### 1. TCP，UDP的区别？
![9e414c7d0a00d1940ac1e946b95c0295.png](en-resource://database/1237:1)

![6b814cd4e5daf418e09a0527a66e8310.png](en-resource://database/1235:1)


### 2. http响应状态码？
- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。


### 3. http为什么要长链接？

### 4. TCP网络拥塞控制
- 慢开始，拥塞避免，快重传和块恢复
详情请看[TCP拥塞控制](https://blog.csdn.net/yechaodechuntian/article/details/25429143)

### 5. select，poll和epoll
- 详情看[大话selcet，poll和epoll](https://cloud.tencent.com/developer/article/1005481)

### 6. ARP和RARP
- ARP是通过目标主机IP查询目标主机的MAC地址
- RARP则是将MAC地址转换为IP地址

### 7. 网络字节序和主机字节序
主机字节序与网路字节序的关系：
主机A的主机字节序------------->网络字节序------------------->主机B的主机字节序
- 将十六进制的地址转换成点分十进制的流程是：
十六进制------->htonl()(网络字节序)-------->inet_ntop()(将IP地址转换点分十进制)
- 将点分十进制转换成十六进制的流程：
点分十进制------>inet_pton()(将点分十进制转换成IP地址)------>ntohl()(主机字节序)

### 8. HTTPS为什么是安全的？

### 9. SSL握手
- 客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
![0569d6b8497e72d72afba8bee2e22d3c.png](en-resource://database/1232:1)

### 10. HTTP报文的格式
- 一个HTTP请求报头由**请求行，请求头，空行，请求数据**四部分组成。
![e668bbcfa924504d57b6e6d3135302a5.png](en-resource://database/1233:1)
- HTTP响应也由三部分组成：**状态行，消息报头，相应正文**。
[详情](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html)

### 11. 网络编程设计模式？
- Reactor： 同步阻塞IO模式。注册对应读写事件处理器，等待事件发生进而调用事件处理器处理事件。
 ![a25750048396510c082c2b69768dbaf9.png](en-resource://database/1234:1)
 
- Proactor： 异步IO模式。

- 半同步和半异步模式：
  上层的任务(数据库查询，文件传输等）使用同步IO模式，简化了编写并行程序的难度。
  下层的任务(网络控制器的中断处理)使用异步IO模式，提供了执行效率。

### 12. connect会长时间阻塞，怎么解决？
- 使用定时器。
- 采用非阻塞模式，设置非阻塞，返回之后用select检测状态。

### 13. keepalive是什么？
- keepalive是TCP中可检测死连接的一种机制。
1). 如果主机可达，对方会响应ACK，就默认连接时存活的。
2). 如果可达，但应用程序退出，对方发送RST，发送TCP撤销连接。
3). 如果可达，应用程序崩溃，对方发送FIN
4). 如果主机不响应ACK，RST，继续发送直到超时，就撤销连接。

### 14. 如果client突然断电了，服务器如何快速知道？
- 使用定时器
- 使用TCP的keepalive功能。

### 15. 为什么TCP能保证包的发送顺序，而UDP无法保证？
- 因为TCP发送的顺序是按照序号发送，有确认机制和超时重传机制，而UDP是不可靠的发送机制。

### 16. epoll有哪些模式？
- epoll有LT和ET两种模式，LT是默认模式。在LT下，只要fd还有数据可读，每次epoll_wait都会返回它的事件。
- ET又称为“高速”模式，它只会通知一次，直到下一次再有数据流之前都不会提示，无论此fd中是否还有数据可读。所以在ET模式下，一定要把buffer读完。

### 17. 网络中，如果客户端突然掉线或者重启，服务端如何快速知道？
- 若客户端突然掉线或者重启，服务端会收到复位信号。

### 18. HTTP的优缺点？
- 支持客户/服务器模式
- 简单快速
- 灵活
- 无连接
- 无状态
- 缺点是不够安全

### 19. TCP拥塞控制中如何感知到网络拥塞？
- 当出现拥塞时，这条路径上的某台路由器缓存会溢出，导致数据丢弃，丢弃的数据会引起发送方的丢失事件。故是通过**TCP发送方通过丢包事件感知到这条路径上出现网络拥塞**

### 20. TCP四次挥手的细节
- 客户端主动关闭，像服务端发送FIN，此时状态为FIN_WAIT1
- 服务端收到后，设置状态为CLOSE_WAIT，并向客户端发送ACK
- 客户端收到后，设置状态为FIN_WAIT2,
- 服务端没有数据发送后，向客户端发送FIN，并设置状态为LAST_ACK
- 客户端收到后，设置状态为TIME_WAIT，并发送ACK
- 服务端收到后，设置状态为CLOSED，并关闭连接

### 21. TCP三次握手的细节
- 客户端调用connect尝试连接服务器，向服务器发送SYN j，设置状态为SYN_SENT
- 服务端调用完socket，bind，listen，在调用accept阻塞时，收到客户端发送的SYN。设置状态为SYN_RCVD，并向客户端发送SYN k ACK j+1
- 客户端收到后，设置状态为ESTABLISHED，并向服务端发送ACK k+1
- 服务端收到后，设置状态为ESTABLISHED，三次握手完成

### 22. TCP/UDP编程模型
![7ac711617fb2f63a8d39487afdf737f0.png](en-resource://database/1236:1)

### 23. MTU和MSS
- IPV4的数据报最大大小是65535字节，包括IPV4首部。许多网有一个硬件规定的MTU，以太网的MTU是1500字节，如果IP数据报超过相应链路的MTU，则需要分片。
- TCP有一个MSS(最大分节大小), 用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。MSS经常设置为MTU减去IP和TCP首部的固定长度。如果MSS+TCP首部+IP首部>MTU，那么IP报文就需要分片


### 24. socket发送缓冲区和接受缓冲区的如何设计？

### 25. 如何解决TCP粘包问题
- TCP：
- 发送固定长度的消息
- 把消息的尺寸和消息一块发送
- 使用特殊标记来区分消息间隔

### 26. TCP心跳包设计
- 心跳包主要是用于长连接的保活和断线处理

### 27. 为什么建立连接时三次握手，断开连接时四次挥手？
- 首先要说明的是，TCP中的ACK起确认作用，SYN起同步作用。在建立连接时，服务器在LISTENING状态下，接收到客户端发送来的SYN报文后，可以将ACK，SYN放在一个报文发送。但在断开连接时，发送方发送FIN仅仅表示是发送方没有数据发送，但并不保证是否有数据要接收，故需要等待接收方发送FIN时才可说明此次连接没有数据要收发，也即才能断开连接。

### 28. 为什么在TIME_WAIT状态还需等待2MSL后才能返回CLOSED状态？
- MSL(Maximun segment lifetime)最长报文段寿命，它时任何报文段在网络上存在的最长的时间。
- 等待2MSL是因为TCP是可靠的全双工连接，也就是说当最后的ACK丢失后，被动关闭端会重新发送FIN，因此主动关闭端需要维持状态，等待重新发送的FIN。
- 保证TCP协议的全双工连接能够可靠关闭
- 保证这次连接的重复数据段从网络中消失


### 29. TCP，UDP，IP包的最大长度？
- UDP整个包最大长度是65535，包头长度是65535-20=65515
- TCP整个包的最大长度是由MSS决定的，MSS就是TCP数据包每次传输的最大长度。为了到达最大传输长度，往往用MTU(减去IP包头20byte和TCP包头20Byte，故一般取1460)
- IP包的大小由MTU决定

### 30. DNS用的是TCP协议还是UDP协议？
- DNS同时占用TCP和UDP的53端口。
- DNS的规范规定了两种类型的DNS服务器，一种是主DNS服务器，一个叫辅DNS服务器。在一个区中，主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅DNS服务器则从主DNS服务器读取数据信息。当辅DNS服务器启动时，需要与主DNS服务器通信，传输数据信息，成为区传送。
- 区传送的时候使用TCP协议
- 域名解析的时候使用UDP协议：客户端向DNS服务器请求域名的时候，一般内容不会超过512个字节

### 31. HTTP缓存机制
- 客户端第一次请求数据时，缓存数据库没有缓存
![dd4dbce1c7518d38863506d2775b69de.png](en-resource://database/1435:1)

- HTTP缓存有多种规则，可以简单的概括为**强制缓存**和**对比缓存**：
- **降至缓存**如果生效，不需要再和服务器发生交互，而**对比缓存**无论是否失效，都需要和服务器发生交互。
![271509c0545a3850955b45e7d90d70b5.png](en-resource://database/1436:1)
![7040a628772461880ca0df43f99922bf.png](en-resource://database/1437:1)

### 32. TCP半连接与完全连接队列
![27d83c5baa8eaba08f244cb8ae4aa634.png](en-resource://database/1438:1)

- server端的半连接队列(syn队列)：该条目表示服务器已经收到了客户端的syn包，并向客户端发出确认，正在等待客户的确认包。
- server端的完全连接队列(accept队列)：三次握手时，当server收到客户端的ack报文后，会进入一个accept队列

### 33. IP分片和TCP分段
- IP分片的主要原因是MTU，TCP分段的主要原因是MSS
- IP分片主要在网络层，重组也是在网络层；TCP分段是在传输层，并在传输层重组

### 34. HTTP1.1新特性
- 默认持久性连接节省通信量
- 客户端可以同时发送多个HTTP请求，而不用一个个等待
- 断点续传原理

### 35. Accept惊群？
- 惊群现象是指多进程(线程)在同时阻塞等待同一事件的时候，如果等待的事件发生，那么他就会唤醒所有等待的进程(线程)，但最后只要一个获得这个时间的执行权。
- 解决方案：
1. 可以引入标记位**WQ_FLAG_EXCLUSIVE**
- epoll惊群现象？？？


### 36. TCP如何保证数据的顺序？
- 主机每次发送给数据时，TCP给每个数据包分配一个序号并且在一个特定的时间内等待主机对分配这个序列号进行确认
- 如果发送主机在一个时间内没有收到接收主机的确认，则发送主机会重传此数据包
- 接收主机利用序列号对接收的接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序
- 接收主机一旦收到以经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理 


## 并不熟悉的设计模式
### 1. 单例模式
- 作用：保证一个类只有一个实例，使得系统中只有唯一的一个对象实例。
- 应用：常用于资源管理，如日志，线程池等
```cpp
class Singleton{
public:
    static Singleton &getInstance(){
        static Singleton singleton;
        return sigleton;
    }
private:
    Singleton();
    Singleton(Singleton const Singleton&);
    Singleton &operator=(Singleton const Singleton &);
}
```

### 2. 工厂模式
- 工厂模式分为：简单工厂模式，工厂方法模式，抽象工厂模式
- 简单工厂模式，将不同的产品创建定义一个工厂类，将产品的类型作为参数传入到工厂的创建函数，根据类型的分支选择不同的产品构造函数。
```cpp
typedef enum ProductType{
    TypeA,
    TypeB,
    TypeC
}PRODUCTYPE;


// 产品抽象类
class Product{
public:
    virtual void show() = 0;
}

class ProductA : public Product{
public:
    void show(){ cout << "ProductA";}
}
class ProductB: public Product{
public:
    void show(){ cout << "ProdudctB"; }
}
class ProductC: public Product{
public:
    void show(){ cout << "ProductC;" }
}

// 工厂类
class Factory{
public:
    Product *CreateProduct(PRODUCTYPE type){
        switch(type){
        case typeA:
            return new ProductA();
        case typeB:
            return new ProductB();
        case typeC:
            return new ProductC();
        default:
            return nullptr;    
        }
    }
}
```
- 工厂方法模式，工厂方法模式在简单工厂模式的基础上增加对工厂的基类抽象，不同的产品创建不同的工厂创建，相比于简单工厂模式，更利于后期产品的扩展。
```cpp
typedef enum ProductType{
    TypeA,
    TypeB,
    TypeC
}PRODUCTYPE;


// 产品抽象类
class Product{
public:
    virtual void show() = 0;
}

class ProductA : public Product{
public:
    void show(){ cout << "ProductA";}
}
class ProductB: public Product{
public:
    void show(){ cout << "ProdudctB"; }
}

class Factory{
public:
    virtual Product *createProduct() = 0;
};

class FactoryA: public Factory{
public:
    Product *createProduct(){ return new ProductA(); }
};
class FactoryB: public Factory{
public:
    Product *createProduct(){ return new ProductB(); }
};
class FactoryC : public Factory{
public:
    Product *createProduct(){ return new ProductA(); }
};
```




## 常用的Linux
### 1. linux文本处理三剑客
- awk：以字段为单位进行处理 
  awk '{[pattern] action}' {filename}
- grep: 文本内容搜索
  grep 'search' filename
- sed:  实现数据的替换，删除，增加，选取等
  sed '命令' filename
  
### 2. 如何查看端口是否被占用？
- lsof -i ： port
- netstat -anp | grep port

### 3. 查看cpu
- cat /proc/cpuinfo |grep "model name" && cat /proc/cpuinfo | grep "physical id"

### 4. 内存大小
- cat /proc/meminfo |grep Memtotal

### 5. 磁盘大小
- fdisk -l |grep Disk
- du -h

### 6. ssh登录服务器
- ssh 阿里云的pem username@servername
- 也可通过修改ssh_config的Host，HostName后，用ssh Host登录

### 7. 服务器间传输文件
- 下载文件： scp username@servername:/path/file
   ex: scp root@47.100.100.100:/root/file
- 上传本地文件到服务器：scp /pth/file username@servername:/path/file
- 若要传文件夹，用 scp -r

### 8. 查看TCP状态
- netstat -nat 查看TCP各个状态的数量
 natstat 的参数：
  -t 显示TCP相关选项
 -u 仅显示UDP相关选项
 -n 拒绝显示别名
 -l 仅列出listen的服务状态
 -p 显示建立连接的程序名
- lsof -i : port 可以检测打开的套接字的状况


### 9. gdb调试
- 常用的参数：
-s/-symbol 从指定文件读取符号表
-c/-core 调试coredump文件
- 调试coredump文件：
1. 用bt或者where查看内存堆栈


## 必须熟透的手写算法
### 1. 反转链表
```cpp
// 非递归
ListNode *reverse(ListNode *head){
    if(head == nullptr)
        return nullptr;
    ListNode *cur = head;
    ListNode *newhead = nullptr;
    while(cur){
        ListNode *next = cur->next;
        cur->next = newhead;
        newhead = cur;
        cur = next;
    }
    return head;
}
// 递归
ListNode *reverse(ListNode *head){
    if(head == nullptr || head->next == nullptr)
        return head;
    ListNode *p = reverse(head->next);
    head->next->next = head;
    head->next = nullptr;
    return p;
}
```
### 2. 二叉搜索树转双向链表
### 3. 求一个数的平凡根
**思路：**利用二分查找，需注意，一个数的平方根不会超过它的一半。
```cpp
int solution(int x){
    if(x == 0)
        return 0;
    // 用long long防止算术溢出
    long long left = 0;
    // x的平方根不会大于(x / 2) +1
    long long right = x / 2 + 1;
    while(left <= right){
        long long mid = (left + right) / 2;
        long long res = mid * mid;
        if(res == x)
            return mid;
        else if(res < x)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return right;
}
```
### 4. 字符串左移右移
**思路：** 利用转置的思想，$BA = (A^TB^T)^T$,故字符串str左移k位，即先逆转str(0, k-1),在逆转str(k, n-1),最后整个字符串反转。
右移的话，是先反转str(0, n-k-1),再反转str(n-k, n-1),最后反转整个字符串。

### 5. 最大连续子序列和
**思路：** 最大连续子序列只能是以位置0~n-1中某个位置结尾。当遍历到第i个元素时，判断它前面的连续子序列和是否大于0，如果大于0，则以位置i结尾的最大连续子序列和为元素i和前面的连续子序列和相加。否则，则以位置i结尾的最大连续子序列和为元素i。
```cpp
int maxsequence3(int a[], int len)
{
    int maxsum, maxhere;
    maxsum = maxhere = a[0];   //初始化最大和为a【0】
    for (int i=1; i<len; i++) {
        if (maxhere <= 0)
            maxhere = a[i];  //如果前面位置最大连续子序列和小于等于0，则以当前位置i结尾的最大连续子序列和为a[i]
        else
            maxhere += a[i]; //如果前面位置最大连续子序列和大于0，则以当前位置i结尾的最大连续子序列和为它们两者之和
        if (maxhere > maxsum) {
            maxsum = maxhere;  //更新最大连续子序列和
        }
    }
    return maxsum;
 }
```

### 6. 括号匹配问题
**思路：** 括号匹配即使栈应用的问题，简单的括号匹配可以用栈与字典实现：
```cpp
bool isValid(string str){
    if(str.size() & 0x1 == 1)
        return false;
    map<char, char> buckets;
    buckets.insert({')', '('};
    buckets.insert({']', '['};
    buckets.insert({'}', '{'};
    stack<char> s;
    for(auto c : str){
        if(c == '(' || c == '[' || c == '{')
            s.push(c);
        else if(c == '}' || c == ']' || c == '}'){
            if(s.empty())
                return false;
            if(buckets[c] != s.top())
                return false;
            s.pop();
        }
    }
    if(s.empty())
        return true;
    return false;
}
```
**进阶：** 若是要求空间复杂度为O(1),则可根据双指针的思路来做。假设有

### 7. 二叉树任意两个节点的最短路径(两个节点的公共父节点）
**思路：** 找两个节点的公共祖先问题.
- 方法1，利用递归方法，分别在左子树和右子树中查找p，q两个节点。
```cpp
TreeNode *findAncestor(TreeNode *root, TreeNode *p, TreeNode *q){
    if(p == nullptr || q == nullptr || root == p || root == q)
        return root;
    TreeNode *left = findAncestor(root->left, p, q);
    TreeNode *right = findAncestor(root->right, p, q);
    return left == nullptr ? right : (right == nullptr ? left : root);
}
```
- 方法2：利用并查集

### 8. 最大公共子序列
**思路：** 动态规划
```cpp
int longestCommonSubsequence(string text1, string text2) {
        if(text1.size() < 1 || text2.size() < 1)
            return 0;
        int len1 = text1.size(), len2 = text2.size();
        vector<vector<int>> dp(len1+1, vector<int>(len2+1, 0));
      
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                dp[i][j] = max(max(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1] + (text1[i-1] == text2[j-1]));
            }
        }
        return dp[len1][len2];
    }
```

### 9. 实现strStr()
**思路：** 
1. 暴力法，挨个遍历，这样会有重复的运算
```cpp
int strStr(string haystack, string needle) {
        if(haystack.size() < 1 && needle.size() < 1)
            return 0;
        if(haystack.size() < 1 && needle.size() > 1)
            return -1;
        if(needle.size() < 1)
            return 0;
        int i = 0, j = 0;
        while(i < haystack.size()){
            while(j < needle.size()){
                if(haystack[i] == needle[j]){
                    i++;
                    j++;
                }
                else{
                    break;
                }
            }
            if(j == needle.size()){
                return i - needle.size();
            }
            else{
                i = i - j + 1;
                j = 0;
            }
        }
        return -1;
    }
```
2. KMP算法：相较于暴力法，KMP主要是减少了回溯的次数，用next数组来表示要回溯的位置，next数组的确定主要是根据PMT(部分匹配表)得来的，PMT的性质是找字符串的前缀集合和后缀集合交集的最大长度。然后将器右移一位可得next数组。
![d9eba53701cee80213e972b2131c93f0.png](en-resource://database/1239:1)


```cpp
int KMP(char * t, char * p)
{ 
    int i = 0; int j = 0; 
    while (i < strlen(t) && j < strlen(p)) {
        if (j == -1 || t[i] == p[j])  {
            i++; j++; 
        } else
            j = next[j]; 
    } 
    if (j == strlen(p)) 
        return i - j; 
    else 
        return -1;
}


void getNext(char * p, int * next)
    {
        next[0] = -1;
        int i = 0, j = -1;

        while (i < strlen(p))
        {
            if (j == -1 || p[i] == p[j])
            {
                ++i;
                ++j;
                next[i] = j;
            }	
            else
                j = next[j];
        }
    }

```

### 10. 实现strcpy，strlen，strcat，strcmp
- strcpy：注意内存重叠的问题
```cpp
char *Istrcpy(const char *src, char *des){
    if(src == nullptr || des == nullptr)
        return nullptr;
    if(src == des)
        return des;
    int len = strlen(src);
    if(des < src || src + len < = des){
        char *d = des;
        char *s = src;
        while(len--)
            *d++ = *s++;
    }
    else{
        char *d = des + len - 1;
        char *s = src + len - 1;
        while(len--)
            *d-- = *s--;
    }
    return des;
}
```
- strlen:
```cpp
int strlen(const char *src){
    if(src == nullptr)
       return -1;
    int len = 0;
    while(*src++ != '0')
        len++;
    return len; 
}
```
strlen与sizeof的区别：
1). sizeof是运算符，strlen是库函数。sizeof在编译的时候就计算出类型的长度，strlen则是到运行时才可以计算出，也通常用来计算字符串的长度。
2). 数组做sizeof不退化，传递给strlen就退化成指针了。

- strcat:
```cpp
char *strcat(const char*src, char *des){
    if(src == nullptr || des == nullptr)
        return nullptr;
    char *res = des;
    while(*des++ != '\0');
    while((*des++ = *src++) != '\0');
    return res;
}
```
- strcmp:
```cpp
int strcmp(const char*cmp1, const char *cmp2){
    if(cmp1 == nullptr || cmp2 == nullptr)
        return -1;
    while(*cmp1 == *cmp2){
        if(*cmp1 == '\0')
            return 0;
        *cmp1++;
        *cmp2++;
    }
    return *cmp1 - *cmp2;
}
```


### 11. 过河问题
**描述：** 有N个人需要过河，但由于种种原因，只能两个人同时过，如果两个人同时过河，所需的时间以较慢的为准。每个人回来的时间与过去的时间相同。请设计一个让N个人尽快过河的方案。
**思路：** 假设n个人过河的时间为s[1],s[2],...s[n] (假定已经排过序). 可以先从人数上考虑：当n=1或n=2时，过河的时间为s[1]或s[1]+s[2], 当n=3时，过河最少的时间即为，花费最小的人和任意一个人过河，最小的再回来，之后再一块过河，总花费为s[1]+s[2]+s[3]. 
当n>3时，有两种考略方案：
1). 最容易想到的是，最小的和最大的一起过河，最小的再回来，再跟次小的一块过，一直循环。花费为s[n]+s[1]+s[n-1]+s[1]
2). 另一个是，最小的和次小的一起过河，最小的再回来，之后最大的和次大的一起过，此小的再回来。花费为s[2]+s[1]+s[n]+s[2]
最后取两者最小的即为n>3的花费。
```cpp
int solution(vector<int> &s){
    if(s.size() < 1)
        return 0;
    sort(s.begin(), s.end());
    int ret = 0;
    if(n > 3){
        while(n > 3){
            ret += min(s[n-1] + s[0] + s[n-2] + s[1], s[1] + s[0] + s[n-1] + s[1]);
            n -= 2;
        }
    }
    if(n <= 2)
        ret += s[n-1];
    else if(n==3)
        ret += s[0] + s[1] + s[2];
    return ret;
}
```

### 12. 两个链表的公共节点
```cpp
ListNode *findComNode(ListNode *head1, ListNode *head2){
    if(hread1 == nullptr || head2 == nullptr)
        return nullptr;
    int len1 = getListLen(head1), len2 = getListLen(head2);
    ListNode *listLong = len1 > len2 ? head1 : head2;
    ListNode *listShort = len1 > len2 ? head2 : head1;
    int dif = len1 > len2 ? len1 - len2 : len2 - len1;
    whle(dif--)
        listShort = listShort->next;
    while((listLong != nullptr) && (listShort != nullptr) && (listLong != listShort)){
        listLong = listLong->next;
        listShort = listShort->next;
    }
    return listLong;
}
```

### 13. atoi和atof
- atoi
```cpp
int my_atoi(string str){
    if(str.size() < 1)
        return 0;
    int i = 0;
    while(str[i] == ' ')
        i++;
    int flag = 1;
    if(str[i] == '+')
        i++;
    if(str[i] == '-'){
        i++;
        flag = -1;
    }
    long num = 0;
    while(i < str.size() && isdigit(str[i])){
        int digit = str[i++] - '0';
        num = num * 10 + digit;
        if(flag == 1 && num > INT_MAX)
            return INT_MAX;
        if(flag == -1 && -1 * num < INT_MIN)
            return INT_MIN;
    }
    return flag == 1 ? num : -1 * num;
}

```
- atof
```cpp
double my_atof(string str){
    double s = 0.0;
    double d = 10.0;
    int jishu = 0;
    bool flag = false;
    int i = 0;
    while(str[i] == ' ')
        i++;
    if(str[i] == '+')
        i++;
    if(str[i] == '-'){
        i++;
        flag = true;
    }
    if(!(str[i] >= '0' && str[i] <= '9'))
        return s;
    while(str[i] >= '0' && str[i] <= '9' && str[i] != '.'){
        s = s * 10.0 + str[i] - '0';
        i++;
    }
    if(str[i] == '.')
        i++;
    while(str[i] >= '0' && str[i] <= '9'){
        s = s + (str[i] - '0') / d;
        d *= 10;
        i++;
    }
    if(str[i] == 'e' || str[i] == 'E'){
        i++;
        if(str[i] == '-'){
            i++;
            while(str[i] >= '0' && str[i] <= '9'){
                jishu = jishu * 10 + str[i] - '0';
                i++;
            }
            while(jishu--){
                s /= 10;
            }
        }
        if(str[i] == '+'){
            i++;
            while(str[i] >= '0' && str[i] <= '9'){
                jishu = jishu * 10 + str[i] - '0';
                i++;
            }
            while(jishu--)
                s *= 10;
        }    
    }
    return s * (flag ? -1.0 : 1.0);
}
```

### 14. 给定一个坐标，求与x轴的夹角
```cpp
float jiajiao(float x, float y){
    if(x == 0.0 && y == 0.0)
        return 180;
    float res = 0.0;
    float dist = sqrt(x * x + y * y);
    float pi = 3.14159265265;
    res = acos(x / dist) * 180 / pi;
    if(y < 0)
        return 360 - res;
    return res;
}
```

### 15. 排序链表
- 快排链表
```cpp
void QuickSort(ListNode *head, ListNode *end){
    if(head != end){
        ListNode *pivot = partition(head, end);
        QuickSort(head, pivot);
        QuickSort(pivot->next, end);
    }
}

ListNode *pivot(ListNode *head, ListNode *end){
    int key = head->val;
    ListNode *p = head;
    ListNode *q = p->next;
    while(p != end){
        if(p->val < key){
            p = p->next;
            swap(p->val, q->val);
        }
        q = q->next;
    }
    swap(p->val, q->val);
    return p;
}
```

### 16. 洗牌算法


### 17. 三数之和
**思路：** 先排序，之和再找target-nums[0]-nums[1]


### 18. 队列模拟栈
**思路：** 
- 两个队列模拟有两种方法，一种是在push上进行操作，每次push前都把q1中的元素放到q2中，之后再push新元素到q1中，然后再将q2中的元素放回到q1。pop的时候只是弹出q1中的元素。
-第二种是在pop上进行操作。每次pop都将前n-1个元素放入到q2中，弹出第n个元素，之后再将q2中放回q1中。
- 用一个队列模拟。先push新元素到q中，之后再循环将旧元素入队。

### 19. 查找有重复元素的非降序列中第一次出现的数字
**思路：** 变形的二分查找。当找到相等元素时，通过缩短边界继续寻找。但是需要时刻注意left，right的取值问题，要考虑清楚查找的区间。


### 20.  判断大小端，并转换int的大小端
**思路：** 大端指的是数据的低字节存放在高地址处，高字节存放在低地址。小端相反。
```cpp
void judgeEndian(){
    union u{
        int a;
        char b;
    };
    u.a = 0x1234;
    if(u.b == 0x12){
        printf("big endian\n");
    }
    else{
        printf("litlle endian\n");
    }
}

//转换大小端，利用位操作
uint32_t reverse_uint32t(uint32_t value){
    return (value & 0x000000ff) << 24 | (value & 0x0000ff00) << 8 | (value & 0xff000000) >> 24 | (value & 0x00ff0000) >> 8;
}
```

### 21. 去除字符串开头和结尾的空格
```cpp
void trimLeftSpace(string &str){
    str.erase(str.begin(), find_if(str.begin(), str.end(), [](int ch){return !isspace(ch);}));
}
void trimRightSpace(string &str){
    str.erase(find_if(str.rbegin(), str.rend(), [](int ch){ return !isspace(ch);}).base(), str.end());
}
```

### 22. 大数相加
**思路：** 当内置类型存不下大数的情况下，一般用字符串来模拟大数相加。
```cpp
string addString(string &num1, string &num2){
    int i = num1.size()-1;
    int j = num2.size()-1;
    int carry = 0;
    string res = "";
    while(i >=0 || j >=0 || carry){
        long sum = 0;
        if(i >= 0){
            sum += num1[i--] - '0';
        }
        if(j >= 0){
            sum += num2[j--] - '0';
        }
        sum += carry;
        carry = sum / 10;
        sum %= 10;
        res = res + to_string(num);
    }
    reverse(res.begin(), res.end());
    return res;
}
```

### 23. 字符串相乘
**思路：** 模拟竖式乘法，本质上就是字符串相加。
```cpp
string multiString(string &num1, string &num2){
    int n1 = num1.size();
    int n2 = num2.size();
    string res(n1+n2, '0');
    for(int i = n1 - 1; i >= 0; i--){
        for(int j = n2 - 1; j >= 0; j--){
            int tmp = (res[i+j+1]-'0')+(num1[i]-'0') * (num2[j]-'0');
            res[i+j+1] = tmp % 10 + '0';
            res[i+j] += tmp / 10;
        }
    }
    // 去除首位'0'
    res.erase(res.begin(), find_if(res.begin(), res.end(), [](int ch){ return ch != '0';}));
    return res;
}
```

### 24. 最小编辑距离
**思路：** 动态规划。定义dp[i][j]表示字符串s1变换成s2需要的最小操作数。其中，状态变化有：
若s1[i-1]==s2[j-1],则dp[i][j] = dp[i-1][j-1]
若s1[i-1] != s2[j-1]:
替换，dp[i][j] = dp[i-1][j-1]+1;
如果s1[0,i-1) == s2[0,j],则删除 s1[i-1], dp[i][j] = dp[i-1][j] + 1;
如果s1[0,i)+s2[j-1] == s2[0,j],则增加s2[j-1], dp[i][j] = dp[i][j-1] + 1;
```cpp
int miniDistance(string word1, string word2){
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m+1, vector<int>(n+1,0));
    for(int i = 1; i <= m; i++)
        dp[i][0] = i;
    for(int j = 1; j <= n; j++)
        dp[0][j] = j;
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            if(word1[i-1] == word2[j-1])
                dp[i][j] = dp[i-1]j-1];
            else{
                dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]))+1;
            }
        }
    }
    return dp[m][n];
}
```

### 25. 数据流的中位数
**思路：** 用两个堆来分别保存元素的各一半。
```cpp
class MedianFinder {
    priority_queue<int> lo;                              // max heap
    priority_queue<int, vector<int>, greater<int>> hi;   // min heap

public:
    // Adds a number into the data structure.
    void addNum(int num)
    {
        lo.push(num);                                    // Add to max heap

        hi.push(lo.top());                               // balancing step
        lo.pop();

        if (lo.size() < hi.size()) {                     // maintain size property
            lo.push(hi.top());
            hi.pop();
        }
    }

    // Returns the median of current data stream
    double findMedian()
    {
        return lo.size() > hi.size() ? (double) lo.top() : (lo.top() + hi.top()) * 0.5;
    }
};
```

### 26. 回文链表
**思路：** 利用快慢指针；先找到中点，之后将中点之后的链表反转，然后比较。
```cpp

bool isPalindrome(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return true;
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast->next!=NULL&&fast->next->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
        }
        slow->next=reverseList(slow->next);
        slow=slow->next;
        while(slow!=NULL){
            if(head->val!=slow->val)
                return false;
            head=head->next;
            slow=slow->next;
        }
        return true;
    }
    ListNode* reverseList(ListNode* head) {
        ListNode* pre=NULL;
        ListNode* next=NULL;
        while(head!=NULL){
            next=head->next;
            head->next=pre;
            pre=head;
            head=next;
        }
        return pre;
    }
```

### 27. 无序数组中同时找到最大最小值
**思路：** 用两个变量分别存储最大值和最小值。两个两个比较，较大的与max比较，小的与min比较。
```cpp
void findMaxMin(vector<int> &nums){
    int imin = 0, imax = 0;
    int len = nums.size();
    if(len < 2)
        return;
    if(len % 2 == 0){
        if(nums[0] < nums[1]){
            min = nums[0];
            max = nums[1];
        }
        else{
           min = nums[1];
           max = nums[0];
        }
    }
    else{
        min = max = nums[0];
    }
    int i = 1;
    while(i <len){
       if(nums[i] < nums[i+1]){
            imin = min(nums[i], imin);
            imax = max(nums[i+1], imax);
       }
       else{
           imin = min(nums[i+1], imin);
           imax = max(nums[i], imax);
       }
    }
}
```

### 28. 实现String类
```cpp
class String{
public:
    String(const char *str=nullptr);
    String(const String &another);
    ~String();
    String &operator =(const String &rhs);
private:
    char *m_data;
}

String::String(const char *str){
    if(str == nullptr){
        m_data = new char[1];
        m_data[0] = '\0';
    }
    else{
        m_data = new char[strlen(str)+1];
        strcpy(m_data, str);
    }
}

String::String(const String &anoter){
    m_data = new char[strlen(anoter.m_data)+1];
    strcpy(m_data, another.m_data);
}

String& String::operator=(const String &rhs){
    if(this == rhs)
        return *this;
    delete []m_data;
    m_data = new char[strlen(rhs.m_data)+1];
    strcpy(m_data, rhs.m_data);
    return *this;
}
```

### 29. 合并k个链表
**思路：** 用vector数组保存k个链表，每次遍历找到最小的节点，然后重组。

### 30. 判断链表是否有环
**思路：** 快慢指针.若是要找到入环节点，可以在第一步返回快慢指针相遇的节点后，计算环有几个节点，之后在用一个双指针，先让一个走k步，之后两个指针再同步遍历，直至相遇后，即可求出入环节点。
```cpp
bool isCircleList(ListNode *head){
    if(head == nullptr || head->next == nullptr)
        return false;
    ListNode *slow = head->next;
    if(slow == nullptr)
        return false;
    ListNode *fast = slow->next;
    while(fast != nullptr && fast->next != nullptr){
        if(fast == slow)
            return true;
        slow = slow->next;
        fast = fast->next;
        if(fast != nullptr)
            fast = fast->next;
    }
    return false;
}
```

## 多线程编程
### 1. 生产者消费者问题
- 关系分析：生产者和消费者对缓冲区互斥访问是互斥关系，同时消费者和生产者又是同步关系。
- 伪代码描述如下：
```cpp
semaphore mutex = 1;     // 临界区互斥信号量
semaphore empty = n;   // 空闲缓冲区
semaphore full = 0;      // 缓冲区初始化为空

Producer(){
    while(1){
        produce an item in nextp;    // 生产数据
        P(empty);             // 获取空闲缓冲区单元
        P(mutex);            // 进入临界区
        add nextp to buffer; // 将数据放入缓冲区
        V(mutex);           // 离开临界区
        V(full);              // 满缓冲区加1
    }
}

Consumer(){
    while(1){
        P(full);              // 获取满缓冲区单元
        P(mutex);         // 进入临界区
        remove an item from buffer;   // 从缓冲区取出数据
        V(mutex);        // 离开临界区
        V(empty);       // 空缓冲区数加1
        consume the item;     // 消费数据
    }
}
```
- cpp实现
```cpp
static const int repo_size = 10; // 循环队列的大小
static const int item_total = 20; // 要生产的产品数目

std::mutex mutex;
std::condition_variable full;
std::condition_variable empty;

int item_buffer[repo_size];

static size_t read_pos = 0;
static size_t write_pos = 0;

std::chrono::seconds t(1);

void produce(int i){
    std::unique_lock<std::mutex> lck(mutex);
    // 生产者等待缓冲区为空
    while((write_pos + 1) % repo_size) == read_pos){
        empty.wait(lck);
    }
    item_buffer[write_pos] = i;  // 生产产品
    write_pos++;
    // 如果写入的位置再队列的最后则重新设置
    if(write_pos == repo_size)
        write_pos = 0;
    // 通知消费者产品库不为空
    full.notify_all();
}

void consume(){
    int data;
    std::unique_lock<std::mutex> lck(mutex);
    // 产品缓冲区不为空
    while(write_pos == read_pos){
        full.wait(lck);
    }
    data = item_buffer[read_pos];  // 消费产品
    read_pos++;
    if(read_pos >= repo_size)
        read_pos = 0;
    
    empty.notify_all();
    return data;
}
```

### 2. 读者写者问题
- 关系分析：读者和写者是互斥的，写者和写者之间也是互斥的，读者和读者之间不存在互斥关系
- 伪代码
```cpp
int count = 0;  // 用于记录当前的读者数量
semaphore mutex = 1;  // 用于保护更新count变量时的互斥
semaphore rw = 1;  // 用于保证读者和写着互斥地访问文件

Write(){
    while(1){
        P(rw);    // 互斥访问共享文件
        Writing //写入
        V(rw);  // 释放共享文件
    }
}

Reader(){
    while(1){
        P(mutex);     // 同步访问count变量
        if(count == 0)      //  当第一个读进程读共享文件时
            P(rw);             //  阻止写进程写
        count++;            //  读者计数器加1
        V(mutex);            //  释放互斥变量count
        reading;              //  读取
        P(mutex);             //  互斥访问count变量
        count--;               //  读者计数器减1
        if(count == 0)       // 当最后一个读进程读完后，允许写进程写
            V(rw);
        V(mutex);              // 释放互斥变量count
    }
}
```

### 3. 哲学家进餐问题
- 关系分析：5名哲学家与左右邻居对其中间筷子的访问时互斥关系
- 思路：一是让他们同时拿两个筷子；而是对每个哲学家的动作制定规则(即当一个哲学家左右两边筷子都可用时，才允许他抓起筷子)，避免饥饿或者死锁的现象发生。
- 伪代码
```cpp
semaphore chopstic[5] = {1, 1, 1, 1, 1};
semaphore mutex = 1;      // 设置取筷子信号量

// 第i号哲学家进程
Pi(){
    do{
        P(mutex);        // 在取筷子前获得信号量
        P(chopstic[i]);   // 取左边筷子
        P(chopstic[(i+1)%5]); // 取右边筷子
        V(mutex);        // 释放取筷子的信号量
        eat;                // 进餐
        V(chopstic[i]);   // 放回左边筷子
        V(chopstic[(i+1)%5];  // 放回右边筷子
        think;             // 思考
    }while(1);
}
```

## 费脑筋的智力题
### 1. 有100个真币和1个假币，只知道真币与假币不等重，要求只称两次，得出是真币重还是假币重。
- 各取50个币放在天平两边。
- 如果同样重，则说明这100个都是真币，另外一个是假币。任取一个真币和假币比较重量即可。
- 如果不同重，则说明假币在这个100个当中。将比较重的一边的50个分成两个25，放在天平两端比较重量。如果同重，则说明假币在另外50个中，假币比较轻；如果不同重，则说明假币在这50个中，假币比较重。

### 2. 制胜游戏：Alice和Bob在玩这样一个游戏。给定k个数字a1a2a3..ak,一开始有x坆硬币，Alice和Bob轮流取硬币。每次所取得坆数一定要在a1a2...ak中。Alice先取，取出最后一枚硬币的一方获胜。当双方都采取最优策略时，谁会获胜？


### 3. Nim游戏


## 场景题
### 1. 从一亿个ip找出出现次数最多的IP
- **思路：** 本质就是做一个map-reduce的操作。若是海量数据加载不到内存中，可先按ip地址进行hash(ip) % 1024,将海量ip分别存储到1024个小文件中，每个小文件最多包含4M个ip地址。之后对于每个小文件，可以构建出一个ip作为key，出现次数作为value的hashmap，并记录当前出现次数最多的1个ip，之后将1024个文件进行合并，就可以得到出现次数最多的ip。

### 2. 如何对海量数据去重？
- **思路：** 与第一题类似，可以用hashmap来做。除此之外，也可用位图来做。位图的原理就是用标记数组map[i]表示第i个元素。
位图的数据结构就是一个数组，而 位图的操作（算法） 基本依赖于下面3个元操作
set_bit(char x, int n); //将x的第n位置1，可以通过x |= (x << n)来实现
clr_bit(char x, int n); //将x的第n位清0，可以通过x &= ~(1 << n)来实现
get_bit(char x, int n); //取出x的第n位的值，可以通过(x >> n) & 1来实现
有了上面3个元操作，位图的具体操作就简单了——比如，要对数字int x = 1848105做标记，就可以调用set_bit(bit_map[x/8], x%8);除法看做求“组编号”，x/8即是 以8个位为一个小组，分组到编号为 idx = x/8 的bit_map元素中，然后在组内偏移 lft = x%8 个比特位。

### 3. 支付系统转账过程中并发交易引起的分布式死锁问题
- **思路：** [详细](https://blog.csdn.net/claram/article/details/77853472)